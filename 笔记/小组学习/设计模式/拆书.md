[TOC]

## 03丨面向对象、设计原则、设计模式、编程规范、重构

<img src="/Users/souche/Library/Mobile Documents/com~apple~CloudDocs/工作区/md_include_image/image-20201025201558160.png" alt="image-20201025201558160" style="zoom:50%;" />



## 09丨理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？

- 如何解读原则中的“接口”二字？

  解这条原则的时候，千万不要一开始就与具体的编程语言挂钩，局限在编程语言的“接口”语法中（比如 Java 中的 interface 接口语法）

  ```
  从本质上来看，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。
  “接口”在不同的应用场景下会有不同的解读，比如服务端与客户端之间的“接口”，类库提供的“接口”，甚至是一组通信的协议都可以叫作“接口”。刚刚对“接口”的理解，都比较偏上层、偏抽象，与实际的写代码离得有点远。如果落实到具体的编码，“基于接口而非实现编程”这条原则中的“接口”，可以理解为编程语言中的接口或者抽象类
  
  越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对
  ```
  
- 是否需要为每个类定义接口？

  **设计初衷:**将接口和实现相分离，封装不稳定的实现，暴露稳定的接口

  ```
  如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。
  ```

  

- 注意事项

  1、函数的命名不能暴露任何实现细节。比如：uploadToAliyun() 就不符合要求

  2、封装具体的实现细节。一个功能不能让使用方调用多个细节接口拼装实现，应该对外提供一个包裹所有细节的方法

## 10丨理论七：为何说要多用组合少用继承？如何决定该用组合还是继承？

- 为什么不推荐使用继承？

  ```
  继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种情况下，我们应该尽量少用，甚至不用继承。
  ```

- 组合相比继承有哪些优势？

  ```
  继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。
  ```

- 如何判断该用组合还是继承？

  ```
  鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。在实际的项目开发中，我们还是要根据具体的情况，来选择该用继承还是组合。如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。
  ```

  

## 17 | 理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？

- 概念

  ```
  子类对象（object ofsubtype/derived class）能够替换程序（program）中父类对象（object of base/parentclass）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏
  ```

- 如何理解“里式替换原则”？

  ```
  从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性
  ```

- 哪些代码明显违背了 LSP？

  1、子类违背父类声明要实现的功能

  2、子类违背父类对输入、输出、异常的约定

  3、子类违背父类注释中所罗列的任何特殊说明

## 18 | 理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？

- 如何理解“接口隔离原则”？

  ```
  客户端不应该强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者
  ```

- 把“接口”理解为一组 API 接口集合

  ```
  如果部分接口只被部分调用者使用，那我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口
  ```

  

- 把“接口”理解为单个 API 接口或函数

  ```
  接口隔离原则就可以理解为：函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现
  
  单一职责原则针对的是模块、类、接口的设计。而接口隔离原则相对于单一职责原则，一方面它更侧重于接口的设计，另一方面它的思考的角度不同。它提供了一种判断接口是否职责单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一
  ```

- 把“接口”理解为 OOP 中的接口概念

  ```
  把“接口”理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数
  ```

- **接口隔离原则与单一职责原则的区别**

  ```
  单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考角度也是不同的。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一
  ```

  

## 25 | 实战二（上）：针对非业务的通用框架开发，如何做需求分析和设计？

- **需求分析**

  - 功能性需求分析

    概括功能点：相对于一大长串的文字描述，人脑更容易理解短的、罗列的比较规整、分门别类的列表信息

    图型辅助：给出最终要展示的效果图加强理解，还可以进一步发掘隐藏需求

  - 非功能性需求分析

    **易用性**：框架是否易集成、易插拔、跟业务代码是否松耦合、提供的接口是否够灵活等等

    **性能**    ：集成到业务系统的框架来说，我们不希望框架本身的代码执行效率，对业务系统有太多性能上的影响

    **扩展性** ：使用者可以在不修改框架源码，甚至不拿到框架源码的情况下，为框架扩展新的功能

    **容错性** ：不能因为框架本身的异常导致接口请求出错。要对框架可能存在的各种异常情况都考虑全面，对外暴露的接				口抛出的所有运行时、非运行时异常都进行捕获处理

    **通用性** ：框架在设计的时候，要尽可能通用。要多去思考一下是否还可以适用到其他哪些场景中

- **框架设计**

  对于稍微复杂系统的开发，很多人觉得不知从何开始，可以看考：

  - TDD（测试驱动开发）

  - Prototype（最小原型）的思想

    先聚焦于一个简单的应用场景，基于此设计实现一个简单的原型。尽管这个最小原型系统在功能和非功能特性上都不完善，但它能够看得见、摸得着，比较具体、不抽象，能够很有效地帮助我缕清更复杂的设计思路，是迭代设计的基础

  - 画产品线框图

  - 画系统设计图

  这些方法的目的都是为了让问题简化、具体、明确，提供一个迭代设计开发的基础，逐步推进



## 26 | 实战二（下）：如何实现一个支持各种统计规则的性能计数器？

- 小步快跑、逐步迭代

  1、对于复杂的需求想一下子把所有需求都实现出来，更是一件非常有挑战的事情。一旦无法顺利完成，你可能就会有很强的挫败感，就会陷入自我否定的情绪中；

  2、即便你有能力将所有需求都实现，可能也要花费很大的设计精力和开发时间，迟迟没有产出，你的 leader 会因此产生很强的不可控感

- 面向对象设计与实现

  面向对象设计和实现要做的事情，就是把合适的代码放到合适的类中

  1. 划分职责进而识别出有哪些类

     根据需求描述，先大致识别出几个接口或类

  2. 定义类及类与类之间的关系

     定义类及属性和方法，定义类与类之间的关系

  3. 将类组装起来并提供执行入口

- Review 设计与实现

## 34丨 实战一（上）：通过一段ID生成器代码，学习如何发现代码质量问题

<img src="/Users/souche/Library/Mobile Documents/com~apple~CloudDocs/工作区/md_include_image/image-20201027155537202.png" alt="image-20201027155537202" style="zoom:50%;" />

<img src="/Users/souche/Library/Mobile Documents/com~apple~CloudDocs/工作区/md_include_image/image-20201027155605521.png" alt="image-20201027155605521" style="zoom:50%;" />

## 35丨 实战一（下）：手把手带你将ID生成器代码从“能用”重构为“好用”

- 制定重构计划

  第一轮重构：提高代码的可读性

  第二轮重构：提高代码的可测试性

  第三轮重构：编写完善的单元测试

  第四轮重构：所有重构完成之后添加注释

  

## 36丨 实战二（上）：程序出错该返回啥？NULL、异常、错误码、空对象？

- 函数出错应该返回啥？

  - 返回 NULL 值

    1、有可能会抛出空指针异常；2、代码中就会充斥着大量的 NULL 值判断逻辑；

  - 空对象设计模式

  - 抛出异常

  ```
  对于运行时异常，我们在编写代码的时候，可以不用主动去 try-catch，编译器在编译代码的时候，并不会检查代码是否有对运行时异常做了处理。相反，对于编译时异常，我们在编写代码的时候，需要主动去 try-catch 或者在函数定义中声明，否则编译就会报错
  ```

- 如何处理函数抛出的异常

  - 直接吞掉
  - 原封不动地 re-throw
  - 包装成新的异常 re-throw

  ```
  是否往上继续抛出，要看上层代码是否关心这个异常。关心就将它抛出，否则就直接吞掉。
  是否需要包装成新的异常抛出，看上层代码是否能理解这个异常、是否业务相关。
  如果能理解、业务相关就可以直接抛出，否则就封装成新的异常抛出
  ```

  

## 39丨 运用学过的设计原则和思想完善之前讲的性能计数器项目（上）



## 40丨运用学过的设计原则和思想完善之前讲的性能计数器项目（下）

39、40主要内容是对25、26实现的代码进行优化，代码存在的问题：

1、工具类只有一个静态函数一旦越来越多的统计功能添加进来之后，这个函数的代码量会持续增加，可读性、可维护性就变差了

​	设计成了一个普通的聚合统计类可以通过依赖注入的方式，将其组装进 需要的类中，这样就更加容易编写单元测试；

​	复杂函数拆分成逻辑独立的函数

2、类似的功能类存在重复代码。整个类负责的事情比较多，不相干的逻辑糅合在里面，职责不够单一

​	通过继承解决重复代码，复杂逻辑抽离成单独函数，入口只负责逻辑编排，



##  48丨代理模式：代理在RPC、缓存、监控等场景中的应用

- 结构型模式。

  结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。

- 代理模式

  在不改变原始类（或叫被代理类）的情况下，通过引入代理类来给原始类附加功能。一般情况下，我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式

- 动态代理

  静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板式的“重复”代码，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动态代理来解决。我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类

- 代理模式的应用场景

  代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。除此之外，代理模式还可以用在 RPC、缓存等应用场景中



## 49丨桥接模式：如何实现支持不同类型和渠道的消息推送系统？

- 桥接模式 也叫作桥梁模式

  1、定义：将抽象和实现解耦，让它们可以独立变化

  - 抽象指的并非“抽象类”或“接口”，而是被抽象出来的一套“类库”，它只包含骨架代码，真正的业务逻辑需要委派给定义中的“实现”来完成。

  - 实现也并非“接口的实现类”，而是的一套独立的“类库

    “抽象”和“实现”独立开发，通过对象之间的组合关系，组装在一起

  2、一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展

  ​	非常类似我们之前讲过的“组合优于继承”设计原则，通过组合关系来替代继承关系，避免继承层次的指数级爆炸



## 56 | 观察者模式（上）：详解各种应用场景下观察者模式的不同实现方式

**观察者模式**（Observer Design Pattern）也被称为**发布订阅模式**

在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。

```tex
观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观察者模式。不同的应用场景和需求下，这个模式也有截然不同的实现方式，有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。
```



实现方式上：

- 同步阻塞；

  - 实现方式

    同步调用

    最经典的实现方式，主要是为了代码解耦

- 异步非阻塞；

  - 实现方式

    1.新起一个线程处理；2.mq; 

    能实现代码解耦之外，还能提高代码的执行效率。进程间的观察者模式解耦更加彻底，一般是基于消息队列来实现，用来实现不同进程间的被观察者和观察者之间的交互



## 57 | 观察者模式（下）：如何实现一个异步非阻塞的EventBus框架？

EventBus 翻译为“事件总线”，它提供了实现观察者模式的骨架代码

### Google Guava EventBus

**特点**：支持异步非阻塞模式，同时也支持同步阻塞模式

**使用**

```java
EventBus eventBus = new EventBus(); // 同步阻塞模式
EventBus eventBus = new AsyncEventBus(Executors.newFixedThreadPool(8))；// 异步阻塞模式
  
// 注册观察者
public void register(Object object);
// 删除观察者
public void unregister(Object object);
// 给观察者发送消息
public void post(Object event);

// EventBus 通过 @Subscribe 注解来标明
// 能接收的消息类型是发送消息（post 函数定义中的 event）类型的父类
@Subscribe
public void handleRegSuccess(long userId) {
  notificationService.sendInboxMessage(userId, "...");
}
```



## 64 | 状态模式：游戏、工作流引擎中常用的状态机是如何实现的？

- 什么是有限状态机？

  有限状态机，英文翻译是 Finite State Machine，缩写为 FSM，简称为状态机。状态机有 3 个组成部分：状态（State）、事件（Event）、动作（Action）。其中，事件也称为转移条件（Transition Condition）。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作

  

- 状态机实现方式

  - 分支逻辑法

    最简单直接的实现方式是，参照状态转移图，将每一个状态转移，原模原样地直译成代码

    缺点：代码会包含大量的 if-else 或 switch-case 分支判断逻辑，甚至是嵌套的分支判断逻辑，可读性和可维护性都很差

  - 查表法

    <img src="/Users/souche/Library/Mobile Documents/com~apple~CloudDocs/工作区/md_include_image/image-20201116170022614.png" alt="image-20201116170022614" style="zoom:50%;" />

    相对于分支逻辑的实现方式，查表法的代码实现更加清晰，可读性和可维护性更好

    缺点：要执行的动作简单，对一系列复杂的逻辑操作（比如加减积分、写数据库，还有可能发送消息通知等等），我们就没法用如此简单的二维数组来表示了。这也就是说，查表法的实现方式有一定局限性

  - 状态模式

    状态模式通过将事件触发的状态转移和动作执行，拆分到不同的状态类中，来避免分支判断逻辑

    缺点：状态模式会引入非常多的状态类，会导致代码比较难维护

- 使用建议

  第一种实现方式叫分支逻辑法。利用 if-else 或者 switch-case 分支逻辑，参照状态转移图，将每一个状态转移原模原样地直译成代码。对于简单的状态机来说，这种实现方式最简单、最直接，是首选。

  第二种实现方式叫查表法。对于状态很多、状态转移比较复杂的状态机来说，查表法比较合适。通过二维数组来表示状态转移图，能极大地提高代码的可读性和可维护性。

  第三种实现方式叫状态模式。对于状态并不多、状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能比较复杂的状态机来说，我们首选这种实现方式。



## 72 | 解释器模式：如何设计实现一个自定义接口告警规则功能？

**定义**：解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。

实际上，这里的“语言”不仅仅指我们平时说的中、英、日、法等各种语言。从广义上来讲，只要是能承载信息的载体，我们都可以称之为“语言”，比如，古代的结绳记事、盲文、哑语、摩斯密码等。

要想了解“语言”要表达的信息，我们就必须定义相应的语法规则。这样，书写者就可以根据语法规则来书写“句子”（专业点的叫法应该是“表达式”），阅读者根据语法规则来阅读“句子”，这样才能做到信息的正确传递。而我们要讲的解释器模式，其实就是用来实现根据语法规则解读“句子”的解释器。

解释器模式的代码实现比较灵活，没有固定的模板。我们前面说过，应用设计模式主要是应对代码的复杂性，解释器模式也不例外。它的代码实现的核心思想，就是将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆分一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。



## 73 | 中介模式：什么时候用中介模式？什么时候用观察者模式？

**定义**：中介模式定义了一个单独的（中介）对象，来封装一组对象之间的交互。将这组对象之间的交互委派给与中介对象交互，来避免对象之间的直接交互。

```
中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者说依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要跟 n 个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性。

在使用中介模式的时候，我们要根据实际的情况，平衡对象之间交互的复杂度和中介类本身的复杂度。
```

<img src="/Users/souche/Library/Mobile Documents/com~apple~CloudDocs/工作区/md_include_image/image-20201116174313442.png" alt="image-20201116174313442" style="zoom:50%;" />

**缺点**：原本业务逻辑会分散在各个控件中，现在都集中到了中介类中。中介类有可能会变成大而复杂的“上帝类”（God Class）

**优点**：简化了控件之间的交互



- 对比

  - 中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要跟 n 个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性。

  - 观察者模式和中介模式都是为了实现参与者之间的解耦，简化交互关系。两者的不同在于应用场景上。在观察者模式的应用场景中，参与者之间的交互比较有条理，一般都是单向的，一个参与者只有一个身份，要么是观察者，要么是被观察者。而在中介模式的应用场景中，参与者之间的交互关系错综复杂，既可以是消息的发送者、也可以同时是消息的接收者。

## 81 | 开源实战三（上）：借Google Guava学习发现和开发通用功能模块

做业务开发也会涉及很多非业务功能的开发。我们要有善于发现、善于抽象的能力，并且具有扎实的设计、开发能力，能够发现这些非业务的、可复用的功能点，并且从业务逻辑中将其解耦抽象出来，设计并开发成独立的功能模块，比如类库、框架、功能组件。

- 类库

  提供一组 API 接口

- 框架

  提供骨架代码，能让业务开发人员聚焦在业务开发部分，在预留的扩展点里填充业务代码

- 功能组件

  提供一组具有某一特殊功能的 API 接口，有点类似类库，但更加聚焦和重量级，比如，ID 生成器有可能会依赖 Redis 等外部系统，不像类库那么简单

实际上，不管是类库、框架还是功能组件，这些通用功能模块最大的两个特点就是复用和业务无关。如果你开发的这块代码，业务无关并且可能会被复用，那就可以考虑将它独立出来，开发成类库、框架、功能组件等。

当我们发现了通用功能模块的开发需求之后，如何将它设计开发成一个优秀的类库、框架或功能组件呢？这里我们讲了一些更普适的开发思想，比如产品意识、服务意识、代码质量意识、不要重复造轮子等。

- Google Guava，它是一个开发类库，目标用户是 Java 开发工程师，解决用户主要痛点是，相对于 JDK，提供更多的工具类，简化代码编写，比如，它提供了用来判断 null 值的 Preconditions 类；Splitter、Joiner、CharMatcher 字符串处理类；Multisets、Multimaps、Tables 等更丰富的 Collections 类等等。

- 它的优势有这样几点：第一，由 Google 管理、长期维护，经过充分的单元测试，代码质量有保证；第二，可靠、性能好、高度优化，比如 Google Guava 提供的 Immutable Collections 要比 JDK 的 unmodifiableCollection 性能好；第三，全面、完善的文档，容易上手，学习成本低

## 82 | 开源实战三（中）：剖析Google Guava中用到的几种设计模式

- Builder 模式在 Guava 中的应用

  ```java
  public class CacheDemo {
    public static void main(String[] args) {
      Cache<String, String> cache = CacheBuilder.newBuilder()
              .initialCapacity(100)
              .maximumSize(1000)
              .expireAfterWrite(10, TimeUnit.MINUTES)
              .build();
      cache.put("key1", "value1");
      String value = cache.getIfPresent("key1");
      System.out.println(value);
    }
  }
  ```

  **为什么要使用Build模式**

  一个类包含 n 多成员变量。我们需要在构造函数中，设置这些成员变量的值，但又不是所有的值都必须设置，设置哪些值由用户来决定。为了满足这个需求，我们就需要定义多个包含不同参数列表的构造函数。为了避免构造函数的参数列表过长、不同的构造函数过多。

- Wrapper 模式在 Guava 中的应用

  代理模式、装饰器、适配器模式统称为 Wrapper 模式，通过 Wrapper 类二次封装原始类；

  <img src="/Users/souche/Library/Mobile Documents/com~apple~CloudDocs/工作区/md_include_image/image-20201122212839955.png" alt="image-20201122212839955" style="zoom:50%;" />

  简化 Wrapper 模式的代码实现，Guava 提供一系列缺省的 Forwarding 类。用户在实现自己的 Wrapper 类的时候，基于缺省的 Forwarding 类来扩展，就可以只实现自己关心的方法，其他不关心的方法使用缺省 Forwarding 类的实现

- Immutable 模式在 Guava 中的应用

  一个对象的状态在对象创建之后就不再改变，这就是所谓的不变模式。其中涉及的类就是**不变类**（Immutable Class），对象就是**不变对象**（Immutable Object）。在 Java 中，最常用的不变类就是 String 类，String 对象一旦创建之后就无法改变；

  - 普通不变模式

    对象中包含的引用对象是可以改变的

  - 深度不变模式

    对象包含的引用对象也不可变

<img src="/Users/souche/Library/Mobile Documents/com~apple~CloudDocs/工作区/md_include_image/image-20201122215026305.png" alt="image-20201122215026305" style="zoom:50%;" />

Java JDK 也提供了不变集合类（UnmodifiableCollection、UnmodifiableList、UnmodifiableSet、UnmodifiableMap…）

<img src="/Users/souche/Library/Mobile Documents/com~apple~CloudDocs/工作区/md_include_image/image-20201122215611601.png" alt="image-20201122215611601" style="zoom:50%;" />

```java
public static void main(String[] args) {
    List<String> originalList = new ArrayList<>();
    originalList.add("a");
    originalList.add("b");
    originalList.add("c");
    List<String> jdkUnmodifiableList = Collections.unmodifiableList(originalList);
    List<String> guavaImmutableList = ImmutableList.copyOf(originalList);
    //jdkUnmodifiableList.add("d"); // 抛出UnsupportedOperationException
    // guavaImmutableList.add("d"); // 抛出UnsupportedOperationException
    originalList.add("d");
    print(originalList); // a b c d
    print(jdkUnmodifiableList); // a b c d
    print(guavaImmutableList); // a b c
  }
```



## 83 | 开源实战三（下）：借Google Guava学习三大编程范式中的函数式编程

Google Guava 并没有提供太多函数式编程的支持，仅仅封装了几个遍历集合操作的接口，代码如下所示：

```java
Iterables.transform(Iterable, Function);
Iterators.transform(Iterator, Function);
Collections.transfrom(Collection, Function);
Lists.transform(List, Function);
Maps.transformValues(Map, Function);
Multimaps.transformValues(Mltimap, Function);
...
Iterables.filter(Iterable, Predicate);
Iterators.filter(Iterator, Predicate);
Collections2.filter(Collection, Predicate);
...

```



Google 对于函数式编程的使用还是很谨慎的，认为过度地使用函数式编程，会导致代码可读性变差，强调不要滥用，所以，在函数式编程方面，Google Guava 并没有提供太多的支持。



## 93 | 项目实战二：设计实现一个通用的接口幂等框架（分析）

- 需求场景

  调用方访问公共服务平台的接口(接口包含修改操作（插入操作、update x=x+delta 更新操作）): 超时

-  处理方式

   - 调用方访问公共服务平台接口超时时，返回清晰明确的提醒给用户，告知执行结果未知，让用户自己判断是否重试
   - 调用方调用其他接口，来查询超时操作的结果，明确超时操作对应的业务，是执行成功了还是失败了，然后再基于明确的结果做处理
   - 调用方在遇到接口超时之后，直接发起重试操作。这样就需要接口支持幂等

-  需求分析

   接口调用的这个场景里，幂等的意思是，针对同一个接口，多次发起同一个业务请求，必须保证业务只执行一次

   “幂等号” ：同一业务请求唯一标识

   - **框架的功能性需求**

     ````java
     ///////// 使用方式二：在框架层面处理幂等 //////////////
     // 接口调用方
     Idempotence idempotence = new Idempotence();
     String idempotenceId = idempotence.createId();
     //...通过feign框架将幂等号添加到http header中...
     // 接口实现方
     public class OrderController {
       @IdempotenceRequired
       public Order createOrder(...) {
         //...
       }
     }
     // 在AOP切面中处理幂等
     @Aspect
     public class IdempotenceSupportAdvice {
       @Autowired
       private Idempotence idempotence;
     @Pointcut("@annotation(com.xzg.cd.idempotence.annotation.IdempotenceRequired)")
       public void controllerPointcut() {
       }
       @Around(value = "controllerPointcut()")
       public Object around(ProceedingJoinPoint joinPoint) throws Throwable {
         // 从HTTP header中获取幂等号idempotenceId
         
         // 前置操作
         boolean existed = idempotence.check(idempotenceId);
         if (existed) {
           // 两种处理方式：
           // 1. 查询order，并且返回；
           // 2. 返回duplication operation Exception
         }
         idempotence.record(idempotenceId)
         
         Object result = joinPoint.proceed();    
         return result;
       }
     }
     
     ````

     从使用的角度来说，幂等框架的主要处理流程是这样的。接口调用方生成幂等号，并且跟随接口请求，将幂等号传递给接口实现方。接口实现方接收到接口请求之后，按照约定，从 HTTP Header 或者接口参数中，解析出幂等号，然后通过幂等号查询幂等框架。如果幂等号已经存在，说明业务已经执行或正在执行，则直接返回；如果幂等号不存在，说明业务没有执行过，则记录幂等号，继续执行业务。

   - **非功能性需求**

   ​		1、程序员通过简单的配置和少量代码，就能将非幂等接口改造成幂等接口

   ​		2、幂等框架尽可能低延迟，尽可能减少对接口请求本身响应时间的影响

   ​		3、幂等框架要有高度的容错性。比如，存储幂等号的外部存储器挂掉了，幂等逻辑无法正常运行，这个时候业务接口也			 要能正常服务才行

## 94 | 项目实战二：设计实现一个通用的接口幂等框架（设计）

- 幂等处理正常流程

  幂等号随着请求传递到接口实现方之后，接口实现方将幂等号解析出来，传递给幂等框架。幂等框架先去数据库（比如 Redis）中查找这个幂等号是否已经存在。如果存在，说明业务逻辑已经或者正在执行，就不要重复执行了。如果幂等号不存在，就将幂等号存储在数据库中，然后再执行相应的业务逻辑

  - 第一个阶段是调用方发送请求并被实现方接收

    比如发送请求失败或者超时，幂等号还没有记录下来，重试请求会被执行，符合我们的预期

  - 第二个阶段是执行接口对应的业务逻辑

    - 业务代码异常处理

      - 业务异常 : 业务上不符合预期

        不删除已经记录的幂等号，不允许重新执行同样的业务逻辑；提供删除幂等号的接口由业务方自行判断是否重试

      - 系统异常 : 非业务层面的、系统级的异常；例如:数据库挂掉了，业务代码访问数据库时，就会报告数据库异常

        将已经记录的幂等号删除，允许重新执行这段业务逻辑

      实际上，为了让幂等框架尽可能的灵活，低侵入业务逻辑，发生异常（不管是业务异常还是系统异常），是否允许再重试执行业务逻辑，交给开发这块业务的工程师来决定是最合适的了

    - 业务系统宕机处理

    - 幂等框架异常处理

  - 第三个阶段是将执行结果返回给调用方

    业务逻辑执行完成了，只是在发送结果给调用方的时候，失败或者超时了，这个时候，幂等号已经记录下来，重试请求不会被执行，也符合我们的预期

-  业务系统宕机处理

  - 幂等号已经记录下了，但是因为机器宕机，业务还来得及执行
  - 幂等号成功了，但是在捕获到系统异常之后，要删除幂等号之前，机器宕机

  在存储业务数据的业务数据库（ 比如 MySQL）中，建一张表来记录幂等号；虽然看起来解决方案不优雅，不够智能，不够自动化，但是，这比编写一大坨复杂的代码逻辑来解决，要好使得多

- 幂等框架异常处理

  对于幂等来说，尽管它应对的也是超时重试等特殊场景，但是，如果本不应该重新执行的业务逻辑，因为幂等功能的暂时失效，被重复执行了，就会导致业务出错（比如，多次执行转账，钱多转了）。对于这种情况，绝大部分业务场景都是无法接受的。所以，在幂等逻辑执行异常时，我们选择让接口请求也失败，相应的业务逻辑就不会被重复执行了。毕竟接口请求失败（比如转钱没转成功），比业务执行出错（比如多转了钱），修复的成本要低很多。



## 95 | 项目实战二：设计实现一个通用的接口幂等框架（实现）

- 实现生成幂等号的功能；

  简单点的有取 UUID，复杂点的可以把应用名拼接在 UUID 上，方便做问题排查

- 实现存储、查询、删除幂等号的功能。

   Redis 本身就提供了把“检查 - 设置”操作作为原子操作执行的命令：setnx(key, value)。它先检查 key 是否存在，如果存在，则返回结果 0；如果不存在，则将 key 值存下来，并将值设置为 value，返回结果 1。因为 Redis 本身是单线程执行命令的，所以不存在刚刚讲到的并发问题

- 最小原型代码实现

  ```java
  public class Idempotence {
    private JedisCluster jedisCluster;
    public Idempotence(String redisClusterAddress, GenericObjectPoolConfig config) {
      String[] addressArray= redisClusterAddress.split(";");
      Set<HostAndPort> redisNodes = new HashSet<>();
      for (String address : addressArray) {
        String[] hostAndPort = address.split(":");
        redisNodes.add(new HostAndPort(hostAndPort[0], Integer.valueOf(hostAndPort[1])));
      }
      this.jedisCluster = new JedisCluster(redisNodes, config);
    }
    
    public String genId() {
      return UUID.randomUUID().toString();
    }
    public boolean saveIfAbsent(String idempotenceId) {
      Long success = jedisCluster.setnx(idempotenceId, "1");
      return success == 1;
    }
    public void delete(String idempotenceId) {
      jedisCluster.del(idempotenceId);
    }
  }
  
  ```

  

